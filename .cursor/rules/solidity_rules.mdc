---
description: 
globs: 
alwaysApply: false
---
---
description: Guidelines and best practices for writing Solidity smart contracts in the ZK Mixer project.
globs: contracts/**/*.sol
alwaysApply: true
---

- **General Principles**
    - Follow the Checks-Effects-Interactions pattern to prevent reentrancy vulnerabilities.
    - Use the latest stable Solidity version (currently `^0.8.20` as defined in contracts). Keep pragma version consistent across all contracts.
    - Prioritize security and clarity over micro-optimizations, but be mindful of gas costs.

- **Naming Conventions**
    - `UpperCamelCase` for contracts and libraries (e.g., `ZKMixer`, `MerkleTreeLib`).
    - `mixedCase` for functions, state variables, local variables, and parameters (e.g., `deposit`, `merkleRoot`, `_commitment`).
    - `ALL_CAPS_SNAKE_CASE` for constants (e.g., `DENOMINATION`, `MERKLE_TREE_HEIGHT`).
    - `UpperCamelCase` for events (e.g., `Deposit`, `Withdrawal`).
    - `UpperCamelCase` for custom errors (e.g., `InvalidProof`, `NullifierAlreadySpent`).
    - Prepend parameters with an underscore (`_`) (e.g., `_commitment`, `_recipient`).

- **Code Structure & Layout**
    - Order within contracts: Type declarations, state variables, events, modifiers, constructor, receive/fallback functions, external functions, public functions, internal functions, private functions.
    - Use consistent indentation (4 spaces).

- **Security Best Practices**
    - **Input Validation**: Use `require()` statements with descriptive messages or custom errors for validating inputs and state conditions at the beginning of functions.
        ```solidity
        // ✅ DO
        require(_commitment != bytes32(0), "Commitment cannot be zero");
        // OR
        if (_commitment == bytes32(0)) revert InvalidCommitment();
        ```
    - **Access Control**: Implement access control where necessary (e.g., using OpenZeppelin's `Ownable` or role-based access control if needed).
    - **Reentrancy**: Adhere strictly to Checks-Effects-Interactions. Use OpenZeppelin's `ReentrancyGuard` if complex external calls are unavoidable.
    - **Arithmetic**: Rely on Solidity >=0.8 default checked arithmetic. Be explicit with `unchecked` blocks only when overflow/underflow is impossible or intended and clearly documented.

- **Gas Optimization**
    - Minimize state variable writes (`SSTORE` is expensive).
    - Use `immutable` for variables set only in the constructor.
    - Use `constant` for true compile-time constants.
    - Prefer `calldata` over `memory` for external function parameters where possible (especially for large data like proofs).
    - Cache state variables in local memory variables if read multiple times within a function.

- **Error Handling**
    - Prefer custom errors over `require` strings for better gas efficiency and clearer error identification off-chain.
        ```solidity
        // ✅ DO
        error InvalidProof();
        // ...
        if (!verifier.verifyProof(...)) revert InvalidProof();

        // ❌ DON'T (Less gas efficient)
        // require(verifier.verifyProof(...), "Invalid ZK proof");
        ```

- **Documentation (NatSpec)**
    - Use NatSpec comments (`///` or `/** ... */`) for all public/external contracts, interfaces, functions, events, and state variables.
    - Include `@title`, `@notice`, `@dev`, `@param`, `@return`.
    - Explain the purpose and logic clearly.

- **Testing**
    - Aim for high test coverage using Hardhat (Mocha/Chai).
    - Test edge cases, access control, failure conditions (reverts), and event emissions.
    - Use mocks for external dependencies during unit testing (e.g., mock Verifier).

- **Dependencies**
    - Use audited and well-maintained libraries like OpenZeppelin (`@openzeppelin/contracts`).
    - Specify dependency versions clearly in `package.json`.

    - **ZK Mixer Specifics**
    - **Merkle Trees**:
        - Prefer audited libraries (like OpenZeppelin's upcoming MerkleProof library if suitable, or well-vetted community libraries) over implementing from scratch. Document the chosen library. [Example: `MerkleProof.sol`](mdc:#) <!-- Link to actual library file when chosen -->
        - Be mindful of gas costs when updating/verifying against the tree. Use efficient update patterns if possible.
        - Ensure the tree height (`MERKLE_TREE_HEIGHT`) is appropriate for the desired anonymity set size and gas limits.
    - **Verifier & Proofs**:
        - The `Verifier.sol` contract will be generated by `snarkjs` based on the compiled Circom circuit. Do not modify it manually.
        - When calling `verifyProof` from `ZKMixer.sol`, ensure the public inputs match *exactly* the order and format defined in the Circom circuit. Document this mapping clearly in comments.
        - Pass proof data (`a`, `b`, `c`) as `calldata` for gas efficiency.
        - Use mocks for the `IVerifier` interface in early unit tests before the actual `Verifier.sol` is generated. [Example: `MockVerifier.sol`](mdc:#) <!-- Link to mock file -->
    - **Commitments & Nullifiers**:
        - Use `bytes32` consistently for commitments and nullifier hashes.
        - Ensure the hash function used in Solidity for *generating* commitments (if done on-chain, though usually client-side) matches the one in the Circom circuit (e.g., Poseidon via precompile or library if available/needed, otherwise ensure consistency).
        - Double-check logic for marking nullifiers as spent (`nullifiers[hash] = true;`) happens *after* successful proof verification but *before* the external transfer (Checks-Effects-Interactions).
    - **Fixed Denomination**:
        - Use the `DENOMINATION` constant consistently. Avoid hardcoding the value.
        - Ensure `msg.value` checks are precise.
    - **Relayer Logic**:
        - If implementing the optional relayer, ensure fee calculations are safe from manipulation and overflow.
        - Validate the relayer address and fee amounts strictly in `withdraw`.
        - Transfer funds to the recipient *before* the relayer to prioritize the user in case of unexpected gas issues.
