---
description: 
globs: 
alwaysApply: true
---
---
description: Defines the rigorous workflow for Zero-Knowledge circuit development using Circom and snarkjs (Groth16). Emphasizes security, efficiency, and best practices.
globs: ["circuits/**/*.circom", "scripts/zk*.js", "contracts/Verifier.sol"] # Relevant files
alwaysApply: true
---

- **Core Principle: Rigor & Consistency**
    - This workflow ensures reproducibility, security, and efficiency in ZK component development. Adhere strictly to these steps.
    - Maintain consistency between circuit definitions, Solidity contracts, and frontend interactions, especially regarding public inputs and data types.

- **1. Circuit Design & Implementation (`.circom`)**
    - **Location:** `circuits/` directory (](mdc:.cursor/rules/directory_structure.mdc)).
    - **Main File:** Define the primary circuit logic (e.g., `circuits/mixer.circom`).
    - **Libraries (`circomlib`):**
        - **Utilize `circomlib`:** Prefer audited components from `circomlib` (v2+) for standard operations like hashing (Poseidon), Merkle tree verification (`MerkleTreeChecker`), and comparisons (`Comparators`). Avoid reinventing cryptographic primitives.
        - **Import Path:** Use relative paths from the circuit file to `node_modules/circomlib/circuits/`. Example: `include "../../node_modules/circomlib/circuits/poseidon.circom";`
    - **Hashing:**
        - **Use Poseidon:** Employ the `Poseidon` template from `circomlib` for hashing within the circuit. It is significantly more constraint-efficient than Keccak256 inside ZK circuits.
        - **Consistency:** Ensure the *exact same hash function* (Poseidon configuration, specifically) is used for generating commitments/nullifiers *outside* the circuit (e.g., in Solidity tests or frontend) as is used *inside* the circuit. Mismatches lead to verification failures. Reference: [solidity_rules.mdc](mdc:.cursor/rules/solidity_rules.mdc).
        - **Domain Separation:** Use distinct Poseidon instances or incorporate domain separation constants if hashing different types of data to prevent potential collisions (e.g., hashing `nullifier` vs. hashing `[nullifier, secret]`).
    - **Merkle Trees:**
        - **Use `MerkleTreeChecker`:** Leverage `circomlib/circuits/merkle_tree.circom/MerkleTreeChecker` for verifying Merkle proofs. It handles path validation correctly.
        - **Parameterize Height:** Define the tree height (`levels`) as a template parameter for flexibility and clarity (e.g., `template Mixer(levels)`). Instantiate the `main` component with the correct height matching the Solidity constant (`MERKLE_TREE_HEIGHT`).
    - **Sparse Merkle Trees (SMT):**
        - **SMTVerifier Requirements:** When using `SMTVerifier` components:
            - The **last element** in the `siblings` array **must be zero**
            - At least one earlier sibling (typically second-to-last) **must be non-zero**
            - Follow the pattern for inclusion proofs: `isOld0 = 1` for new leaf insertions
        - **Build Simplified SMT Helper:** Consider implementing a simplified SMT helper class in your scripts to generate valid inputs. See the examples in scripts/generate_inputs.js.
    - **Public Inputs (`main component { public [...] }`)**:
        - **Define Explicitly:** Clearly declare *all* public inputs in the `main` component instantiation. Order matters.
        - **Minimal Set:** Only include signals absolutely necessary for public verification.
        - **On-Chain Matching:** ðŸš¨ **CRITICAL:** The order and number of public inputs defined here *must exactly match* the `input` array expected by the `Verifier.sol` contract generated later. Mismatches are a common source of verification failures.
        - **Include Anchors:** Ensure public inputs include necessary anchors like the `root` and `nullifierHash`. Consider including `recipient`, `relayer`, `fee`, `chainId`, etc., as public inputs to prevent proof replay attacks across different contexts.
    - **Private Inputs:** Define signals for secrets, nullifiers, and Merkle path data. ðŸš¨ **NEVER** commit files containing private input values (e.g., test input `.json` files with secrets) to version control. Use `.gitignore`.
    - **Constraints (`===`, `<==`):**
        - Ensure every calculation relevant to the proof's validity is constrained.
        - Use `assert` statements (`circomlib/circuits/comparators.circom`) for debugging during development to verify intermediate values. Remove or disable asserts for production circuits as they add constraints.

- **2. Circuit Compilation (`circom`)**
    - **Goal:** Convert `.circom` code into R1CS (constraint system) and WASM/C++ (witness computation code).
    - **Command:**
      ```bash
      # Adjust --output path as needed, e.g., build/circuits/
      npx circom circuits/mixer.circom --r1cs --wasm --sym --output build/zk
      ```
    - **Flags:**
        - `--r1cs`: Generate the constraint system file (`mixer.r1cs`). Essential for setup.
        - `--wasm`: Generate the WebAssembly witness calculator (`mixer_js/mixer.wasm`). Needed for frontend/JS environments.
        - `--sym`: Generate the symbol file (`mixer.sym`). Useful for debugging.
        - `--output`: Specify the output directory (e.g., `build/zk/`). Keep build artifacts separate from source.
    - **Verification:** Check that `mixer.r1cs` and `mixer_js/mixer.wasm` (and `mixer.sym`) are created in the output directory.

- **3. Trusted Setup - Groth16 (`snarkjs`)**
    - **Goal:** Generate the proving key (`.zkey` containing private components) and verification key (`verification_key.json`, public). Groth16 requires a circuit-specific setup.
    - **Location:** Perform in the output directory (`build/zk/`) or reference files there.
    - **A. Powers of Tau (Circuit Independent):**
        - **Purpose:** A common cryptographic element reusable across different circuits up to a certain size.
        - **Obtain `.ptau` file:**
            - **Download:** Download a pre-generated, widely participated `.ptau` file from reputable sources (e.g., Perpetual Powers of Tau ceremony) appropriate for your circuit size (constraints). This is recommended for security.
            - **File Size:** The file size depends on the constraint complexity. For 2^15 constraints, expect approximately 36 MB.
            - **Generate (Development Only):** For *testing/development only*, you can generate a small one quickly. ðŸš¨ **DO NOT** use development `.ptau` files for production.
              ```bash
              # Example: Generate a small ptau (e.g., power 12) - ADJUST POWER AS NEEDED
              npx snarkjs powersoftau new bn128 12 pot12_0000.ptau -v
              npx snarkjs powersoftau contribute pot12_0000.ptau pot12_0001.ptau --name="First contribution" -v -e="random text"
              # ... more contributions if desired ...
              npx snarkjs powersoftau prepare phase2 pot12_0001.ptau pot12_final.ptau -v
              ```
        - **Store the final `.ptau` file** (e.g., in `build/zk/`).
    - **B. Phase 2 (Circuit Specific):**
        - **i. Setup (`.zkey` initial):** Generate the first `.zkey` file using the R1CS and final PoT file.
          ```bash
          npx snarkjs groth16 setup build/zk/mixer.r1cs build/zk/pot12_final.ptau build/zk/mixer_0000.zkey
          ```
        - **ii. Contribution (Simulated for Dev):** Add randomness to make the `.zkey` secure. For production, this requires a multi-party computation (MPC) or a secure beacon. For development, a single contribution is sufficient. ðŸš¨ **CRITICAL:** The entropy added here protects the system. A compromised Phase 2 breaks security.
          ```bash
          # Simple contribution for development
          npx snarkjs zkey contribute build/zk/mixer_0000.zkey build/zk/mixer_final.zkey --name="Developer Contribution" -v -e="some random long text entropy"
          ```
        - **iii. Export Verification Key:** Extract the public verification key from the final `.zkey`.
          ```bash
          npx snarkjs zkey export verificationkey build/zk/mixer_final.zkey build/zk/verification_key.json
          ```
    - **Artifacts:**
        - `mixer_final.zkey`: **Private** Proving Key. ðŸš¨ **NEVER** commit this to public Git history. Contains toxic waste.
        - `verification_key.json`: **Public** Verification Key. Safe to commit.

- **4. Generate Verifier Contract (`snarkjs`)**
    - **Goal:** Create the `Verifier.sol` smart contract from the `verification_key.json`.
    - **Command:**
      ```bash
      npx snarkjs zkey export solidityverifier build/zk/mixer_final.zkey contracts/Verifier.sol
      ```
    - **Action:** This command will **overwrite** the `contracts/Verifier.sol` file.
    - **Verification:**
        - Check the generated `contracts/Verifier.sol`. ðŸš¨ **DO NOT** modify this file manually.
        - Ensure the public input array size in its `verifyProof` function matches the number of public inputs defined in `mixer.circom`'s `main` component.

- **5. Input Generation & Witness Calculation**
    - **Goal:** Create valid inputs for your circuit and calculate the witness (`.wtns` file) for them.
    - **A. Generate Valid Inputs:**
        - **Create Helper Scripts:** Implement scripts to generate cryptographically valid inputs (e.g., `scripts/generate_inputs.js`).
        - **Input Requirements:**
            - Ensure cryptographic consistency (e.g., nullifierHash = Poseidon(nullifier, recipient))
            - For SMT circuits, ensure siblings array satisfies the SMTVerifier requirements
            - Store generated inputs in the `/inputs` directory with descriptive names
        - **Example Script Structure:** 
          ```javascript
          // Example pseudocode for generate_inputs.js
          async function generateInputs() {
              // Initialize cryptographic functions (e.g., Poseidon)
              const poseidon = await buildPoseidon();
              
              // Create random values for secret inputs
              const nullifier = generateRandomBigInt();
              const secret = generateRandomBigInt();
              
              // Calculate commitment and other derived values
              const commitment = poseidonHash([nullifier, secret]);
              
              // For SMT, create a valid path with specific requirements:
              // - Last sibling must be zero
              // - At least one earlier sibling must be non-zero
              const pathElements = generateSMTPath(MERKLE_TREE_HEIGHT);
              
              // Generate a valid root based on commitment and path
              const root = calculateRoot(commitment, pathElements);
              
              // Calculate nullifierHash using the EXACT same logic as the circuit
              const recipient = generateRandomBigInt();
              const nullifierHash = poseidonHash([nullifier, recipient]);
              
              // Create the complete input object
              const input = {
                  secret: secret.toString(),
                  nullifier: nullifier.toString(),
                  pathElements: pathElements.map(el => el.toString()),
                  pathIndices: Array(MERKLE_TREE_HEIGHT).fill("0"),
                  root: root.toString(),
                  nullifierHash: nullifierHash.toString(),
                  recipient: recipient.toString()
              };
              
              // Write to file
              writeInputToFile(input, 'inputs/example_input.json');
          }
          ```
        - **Input Variants:** Create different types of inputs for:
            - Simple debugging with small values
            - Complex testing with realistic values
            - Edge cases and error conditions
    - **B. Witness Generation:**
        - **ðŸš¨ IMPORTANT: Prefer CLI Over JS API:** Always use the CLI commands for witness generation rather than the JavaScript API. The CLI tools are more stable and reliable.
        - **Input File:** Use the generated JSON file (e.g., `inputs/example_input.json`) with all required inputs.
        - **Command:**
          ```bash
          # USE THIS CLI APPROACH - More reliable and consistent
          npx snarkjs wtns calculate build/zk/mixer_js/mixer.wasm inputs/example_input.json build/zk/witness.wtns
          
          # AVOID this JS API approach as it can be unstable across Node.js versions
          # const { witness } = await snarkjs.wtns.calculate(input, wasmPath);
          ```
        - **Troubleshooting Witness Generation:**
            - If the witness generation fails with errors like "Cannot read properties of undefined", switch to CLI commands
            - Create a shell script (.sh) to automate the process if you need to run it frequently
            - Ensure all relative paths are correct when running commands
            - For complex workflows, prefer bash scripts or Makefile over Node.js scripts

- **6. Proof Generation (`snarkjs`)**
    - **Goal:** Generate the actual ZK-SNARK proof using the final `.zkey` and the calculated witness.
    - **ðŸš¨ IMPORTANT: Use CLI Command:**
      ```bash
      # More reliable CLI approach
      npx snarkjs groth16 prove build/zk/mixer_final.zkey build/zk/witness.wtns build/zk/proof.json build/zk/public.json
      
      # AVOID JavaScript API if possible
      # const { proof, publicSignals } = await snarkjs.groth16.prove(zkeyPath, witness);
      ```
    - **Outputs:**
        - `proof.json`: Contains the proof components (`pi_a`, `pi_b`, `pi_c`).
        - `public.json`: Contains the values of the public input signals derived from the witness.
    - **Generate Solidity Calldata:**
      ```bash
      # Generates formatted data for Solidity contract calls
      npx snarkjs zkey export soliditycalldata build/zk/public.json build/zk/proof.json > calldata.txt
      ```

- **7. Verification (`snarkjs` / Solidity)**
    - **A. Off-Chain Verification:** Quickly verify the proof against the public inputs using `snarkjs`. Useful for testing and debugging.
      ```bash
      # CLI approach - more reliable
      npx snarkjs groth16 verify build/zk/verification_key.json build/zk/public.json build/zk/proof.json
      
      # AVOID JavaScript API for critical operations
      # const verified = await snarkjs.groth16.verify(vkey, publicSignals, proof);
      ```
      - Expect output indicating `[OK]` if valid.
    - **B. On-Chain Verification:**
        - **Input Formatting:** The proof components (`pi_a`, `pi_b`, `pi_c` from `proof.json`) and public inputs (`public.json`) must be formatted *exactly* as expected by the `Verifier.sol` contract's `verifyProof` function (ABI encoding, array structures, order). Create helper functions (e.g., in `scripts/` or tests) for this formatting.
        - **Contract Call:** Call the `verifyProof` function of the deployed `Verifier.sol` contract (usually via `ZKMixer.sol`) passing the correctly formatted proof components and public inputs.
        - **Public Input Matching:** Double-check that the public inputs passed to `ZKMixer.sol::withdraw` (`_root`, `_nullifierHash`, `_recipient`, etc.) are correctly assembled into the `input` array in the *exact same order* as defined in `mixer.circom` and expected by `Verifier.sol`.

- **8. Common Troubleshooting & Best Practices**
    - **Circuit Compilation Errors:**
        - Check for syntax errors, undefined variables, or incorrect includes
        - Verify that imported templates exist and are properly referenced
    - **Witness Generation Errors:**
        - **ðŸš¨ JavaScript API Issues:** If encountering errors like "Cannot read properties of undefined (reading 'type')" when using the JavaScript API (`snarkjs.wtns.calculate()`), switch to CLI commands (`npx snarkjs wtns calculate`)
        - **ðŸš¨ Create Automation Scripts:** For complex workflows, create shell scripts (.sh) that execute the full pipeline from witness calculation to proof generation
        - **SMTVerifier Line 92:** If error occurs in SMTVerifier line 92, check that your siblings array follows SMT requirements
        - **Hash Verification Failures:** Ensure nullifierHash is calculated identically in the circuit and input
        - **Consistency Checks:** Verify that all private and public inputs are cryptographically consistent
    - **Prove Witness Errors:**
        - Check for constraint violations in your witness
        - Use the `.sym` file to map errors back to specific source lines
    - **Progressive Testing:**
        - Start with simple circuits before complex ones
        - Test each component individually before integration
        - Use small, easy-to-trace values for initial testing
    - **Input Organization:**
        - Store all circuit inputs in the `/inputs` directory
        - Use clear naming (e.g., `debug_input.json`, `test_valid_input.json`)
        - Add inputs to `.gitignore` if they contain sensitive information

- **9. Automation & Scripts**
    - **Prefer CLI-Based Shell Scripts:** Create shell scripts (.sh) for automation instead of Node.js scripts when working with snarkjs
    - **Complete Example Script:**
      ```bash
      #!/bin/bash
      
      set -e  # Exit on any error
      
      # Set up paths
      WASM_FILE="build/zk/mixer_js/mixer.wasm"
      INPUT_FILE="inputs/example_input.json"
      WITNESS_FILE="build/zk/witness.wtns"
      ZKEY_FILE="build/zk/mixer_final.zkey"
      PROOF_FILE="build/zk/proof.json"
      PUBLIC_FILE="build/zk/public.json"
      VERIFICATION_KEY="build/zk/verification_key.json"
      
      # Step 1: Calculate witness
      npx snarkjs wtns calculate "$WASM_FILE" "$INPUT_FILE" "$WITNESS_FILE"
      
      # Step 2: Generate proof
      npx snarkjs groth16 prove "$ZKEY_FILE" "$WITNESS_FILE" "$PROOF_FILE" "$PUBLIC_FILE"
      
      # Step 3: Verify proof
      npx snarkjs groth16 verify "$VERIFICATION_KEY" "$PUBLIC_FILE" "$PROOF_FILE"
      
      # Step 4: Generate Solidity calldata
      npx snarkjs zkey export soliditycalldata "$PUBLIC_FILE" "$PROOF_FILE" > calldata.txt
      ```
    - **Makefile Alternative:** Consider using Makefiles for more complex build processes with dependencies tracking

- **10. Testing in CI/CD**
    - When setting up continuous integration for ZK circuits:
        - Use shell scripts rather than JavaScript for proof generation steps
        - Install snarkjs globally in CI environment (`npm install -g snarkjs`)
        - Cache powers of tau files between runs
        - Create small test circuits to validate full build process quickly

- **11. Iteration**
    - If the circuit (`.circom`) is modified, **all steps from Compilation (2) onwards MUST be repeated** (compilation, setup, verifier generation, witness/proof generation for tests). Phase 1 (Powers of Tau) can be reused if the circuit size limit is not exceeded.